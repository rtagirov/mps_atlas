subroutine  dfsynthe(myrank, sizee, comm, ODFfile) 
! ---- This subroutine calculates the high-resolution opacity on the T-P grid
!      -  decides if ODF tables or just the opacity will be pre-tabulated
!      -  generates the ODFs and writes them out
! ---------------------------------------------------------------------------


!----  important data input files :  
!    tape /  unit = 11 input line data from lowlinesdf
!    tape /  unit = 21 input line data from highlinesdf
!    tape /  unit = 31 input line data from diatomicsdf
!    tape /  unit = 41 input line data from tiolinesdf
!    tape /  unit = 43 input line data from h2olinesdf
!    tape /  unit = 51 input line data from nltelinesa for xlinop
!    tape /  unit = 61 input line data from nltelinesb simple lines
!    tape /  unit = 12 line data selected for each temperature from 11,21,31,41
!    tape /  unit = 14 temporary file of the 0 km/s opacity spectrum
!    tape /  unit = 19 line data for each temperature selected from 51
!------------------------------------------------------------------------------
  use types
  use dfcomm
  implicit none

  include 'common.odfnlte'
  include 'common.ifopbl'      
  include 'common.rhoxbl'
  include 'common.stateb'
  include 'common.tempbl'
  include 'common.depart'
  include 'common.ionsbl'
  include 'common.opsblk'
  include 'common.turbpr'
  include 'common.junkbl'
  include 'common.teffbl'
  include 'common.constb'    

!------------- variables for MPI and file/ folder names
#ifdef MPI
      include 'mpif.h'
      integer :: ierr, error
      integer :: isendbuf(4), ncount, rank, sizenum 

!  for timing ( if needed ): 
!-------------------------------------------------------
!      real(kind=8) :: time0, time1, time2, time3, time4
!      real(kind=8) :: time10, time5, time6, time7, time8
!      real(kind=8) :: Rtime(1425,4),  Atime(1425,4)
!      integer :: tcount

! for balancing T, p loop amound processors
      integer, allocatable:: Tpmask(:,:)
      integer, allocatable:: slaves(:), wslaves(:)
      integer, allocatable:: sendtag(:), recvtag(:), ireq(:)
      integer :: numslave, worktag

      integer ::status_mp(MPI_STATUS_SIZE)  
      character(256):: dirname, continfile      
      character(128):: dumname

      logical, allocatable:: flagmpi(:) 

#endif

      character(256):: newdir, command, currentdir, inputdir 
      character(256):: linloc
      character(30), intent(in) :: ODFfile
      character(30) :: ODFname
      character(len=6)  :: filename
      character(1)  :: velf
      character(128):: fileunit

      integer :: ntemp
      integer :: status, getcwd, nstring 
      integer :: ncid, ier
      integer, intent(in) :: myrank, comm, sizee
      integer :: nstart, nfin, dbug 
!-------------------------------------------------------------
      integer  i,j, m, m2

!--- local variables------------------------!
      double precision  ablog8(3,377)
      double precision  deledge(377),halfedge(377)
      double precision  aedge(377),bedge(377),cedge(377)
      double precision kappa0, freq1000(4000)
      
      
      double precision wl,wlvac,wave
      double precision profilecenter 
!   ---setting highresolution bins:
   
      integer(kind=4) iwlstart, iwlstop, nzero
      double precision lambdabegin, lambdaend


!-------- local variables that were implicit 
      integer :: n1, nu, ncon, nbuff, nelion, nstep, n12, n19, nback, n5dop, n10dop, nedge 
      integer :: lastrec, l       
      integer :: maxred, minred, maxblue, minblue, maxstep  
      integer :: iedge, iteff, istep, iprof, ivo, iv, irec, ik, ia  
! 
      integer :: uninum, check 

      real(kind=4) :: cutoff,   tlog10, profilec   
      real(kind=4) :: x, contmin, dvoigt, plog10,  adamp 
      real(kind=4) :: aa, aau, vv, vvu, u, tabi, tabstep
      real(kind=4) :: vt, vsteps

!------ to read line data from file generated by select lines:
 
      integer(kind=4)  itape12(6,10000)
      real(kind=4) tape12(6,10000)
      equivalence (tape12(1,1),itape12(1,1))

!----   external functions 
      real(kind=8) :: expi

      logical logical2, selline, moretemp, highres
       
!--------------------------------------------------------------
!   Start Calculations:
!--------------------------------------------------------------
      highres = .false. 

! get current working folder
  status = getcwd(currentdir)
#ifdef MPI

!  time0 = MPI_WTIME()
  call get_data_location(1, linloc)

  call convits(int(myrank+1), filename)

  dirname = '/case'//trim(filename)

  command = 'mkdir '//trim(currentdir)//trim(dirname)

  call system(command)

  newdir = trim(currentdir)//dirname

!--- create symbolic link to linelists in each folder:

  command = 'ln -s '//trim(linloc)//'linelists/lowlinesdf.bin '//trim(newdir)//'/fort.11'
  call system(command)
  
  command = 'ln -s '//trim(linloc)//'linelists/highlinesdf.bin '//trim(newdir)//'/fort.21'
  call system(command)

  command = 'ln -s '//trim(linloc)//'linelists/diatomicsdf.bin '//trim(newdir)//'/fort.31'
  call system(command)

  command = 'ln -s '//trim(linloc)//'linelists/tiolinesdf.bin '//trim(newdir)//'/fort.41'
  call system(command)

  command = 'ln -s '//trim(linloc)//'linelists/h2olinesdf.bin '//trim(newdir)//'/fort.43'
  call system(command)

  command = 'ln -s '//trim(linloc)//'linelists/nltelinesdf.bin '//trim(newdir)//'/fort.51'
  call system(command)

  command = 'ln -s '//trim(currentdir)//'/Continum.nc '//trim(newdir)//'/Continum.nc'
  call system(command)

  command = 'ln -s '//trim(currentdir)//'/INPUT/subbin_info.dat '//trim(newdir)//'/subbin_info.dat'
  call system(command)

  command = 'ln -s '//trim(currentdir)//'/INPUT/bin_grid_sizes.dat '//trim(newdir)//'/bin_grid_sizes.dat'
  call system(command)

  inputdir = trim(newdir)

  dumname = '/Continum.nc'
  continfile = trim(newdir)//dumname


!---- open Continuum.nc file where information from previous continuum calculations and partition functions are stored
     call OpenContinum(ncid, continfile, nrhox, ntemp, nufreq, ier)

#else
 
   call get_data_location(0, linloc) 

! --- for non MPI - creat symbolic link in general folder:

   command =  'ln -s '//trim(linloc)//'linelists/lowlinesdf.bin '//trim(currentdir)//'/fort.11'
   call system(command)

   command =  'ln -s '//trim(linloc)//'linelists/highlinesdf.bin '//trim(currentdir)//'/fort.21'
   call system(command)

   command =  'ln -s '//trim(linloc)//'linelists/diatomicsdf.bin '//trim(currentdir)//'/fort.31'
   call system(command)

   command =  'ln -s '//trim(linloc)//'linelists/tiolinesdf.bin '//trim(currentdir)//'/fort.41'
   call system(command)

   command =  'ln -s '//trim(linloc)//'linelists/h2olinesdf.bin '//trim(currentdir)//'/fort.43'
   call system(command)

   command =  'ln -s '//trim(linloc)//'linelists/nltelinesdf.bin '//trim(currentdir)//'/fort.51'
   call system(command)

   call OpenContinum(ncid, 'Continum.nc', nrhox, ntemp, nufreq, ier)

   inputdir = trim(currentdir)//'/INPUT'



#endif

     nufreq3= nufreq/3


! precalculations for high resoution gird------------------------------------------------!

      length = 3507859
      resolu=500000.d0
      ratio=1.d0+1.d0/resolu
      ratiolg=log(ratio)
      wlbeg=8.97666d0
      wlend=10000.0d0
      wlbeg0=wlbeg/ratio
      ixwlbeg=log(wlbeg)/ratiolg
      wbegin=exp(ixwlbeg*ratiolg)

      if(wbegin.lt.wlbeg)then
       ixwlbeg=ixwlbeg+1
       wbegin=exp(ixwlbeg*ratiolg)
      endif

      do i=1,3510
      freq1000(i)=2.99792458d17/wlbeg/ratio**dble(i*1000-999)
      end do

      cutoff=.001d0

      do i=1,10001
        extab(i)=exp(-dble(i-1)*0.01d0)
      end do

      do  i=1,2000
        e1tab(i)=expi(1,dble(i)*.01)
      end do


     ! here all arrays that are needed for the ODFs calculations are allocated
     ! if ifkbin was set before during the read input, then the standart freqgrid 
     ! will be calculated and the wavelength arrays are allocated accordingly

     if (ifkbin) then 
      nsubbin = 12 
      call set_arrays(0, nsubbin, ntemp)
     else 
         open (unit = 78, status = 'old', file=trim(inputdir)//'/subbin_info.dat', form = 'formatted')
         read(78,*) nsubbin, check 
!--- high-resolution opacity tables can be set, for that subbin_info needs 1 subbin,
!     2nd line should have start and stop wavelength in nm 
         if ( nsubbin .eq. 1 ) then 
           highres = .true.
           read(78,*), lambdabegin, lambdaend
         end if 

         close(unit = 78)

         if ( highres ) then 

         ! calculate the bin number   
          nzero=log(wlbeg)/log(1.d0+1.d0/500000.d0)
          iwlstart = int(log(lambdabegin)/ratiolg)-nzero +1
          iwlstop  = int(log(lambdaend)/ratiolg)-nzero+1
          nsizebig = iwlstop - iwlstart + 2  
         else ! if not highresolution read the wavelenght bin number 
       
           open(unit = 95, file = trim(inputdir)//'/bin_grid_sizes.dat', form= 'formatted', &
     &     status = 'old', access = 'sequential' )
!
           read(95,*)  nsizebig
           close(unit = 95)
         
           if (check .ne. (nsizebig) ) then
             write(6,*) 'subbin info does not match freq-grid size'
           end if 

         end if


      call set_arrays(nsizebig, nsubbin, ntemp)
 
     endif


!----- pretabulate voigt function
!     200 steps per doppler width
      vsteps=200. 

      call tabvoigt(vsteps,2001)

!---- set the bin-sizes and subbin sizes
!---- if highresolution bins are calculated
      if (highres) then 
       call dfinterhighres(iwlstart, iwlstop)
         
!---- if filters will be used
      else if (ifilter .eq. 1) then 

       call filter_profile()
       call dfintervals_filter
!---  standard ODFs
      else 

       call dfintervals
      endif 

!---- 
      call vttab

!------------------------------------------------------!
! Precalculations finished                             !
!------------------------------------------------------!
      itemp=0
      iteff = 1
      moretemp = .true.



#ifdef MPI
     call mpi_barrier(MPI_COMM_WORLD, ierr)
   allocate(recvtag(sizee))
   allocate(sendtag(sizee))
   allocate(ireq(sizee))
   allocate(flagmpi(sizee))

   
   do i = 1, sizee
     sendtag(i) = 2000+i
     recvtag(i) = 3000+i

   end do 
 
!------------------------------------------------------------
!    initialise work-destribution among cores
   if (myrank .eq. 0) then
         call ReadContinum ( myrank , comm, 1, ncid, &
     &      wledge, freqedge, cmedge, idmol, momass, freqset, &
     &      tsave, p, t, rho, xne, xnatom, vturb, xnfh2, xnfhe, &
     &      xnfh, continall, contscat, xnfpel4, dopmax, dopple4,&
     &      nrhox, ntemp, nufreq , ier)

      allocate(slaves(sizee-1))
      allocate(wslaves(sizee-1))
      slaves = 0
      wslaves =0
      allocate(Tpmask(ntemp,4))

!  Tp mask evaluates which T values have to be calculated first:
!  this is done be obtaining how far the ln(T) value is away from 10.
!  (This choice is done due to timing the time needed to calculate different T)


      do i = 1, ntemp
       Tpmask(i,1) = int(abs(log(tsave(i))-7.6)*100)
       Tpmask(i,2) = i
      end do 

      call worksort(Tpmask(1,1), (ntemp), Tpmask(1,3), Tpmask(1,2), Tpmask(1,4))


      do i = 1, sizee-1
        call mpi_Isend(Tpmask(i,2), 1, mpi_integer, i, sendtag(i), comm, ireq(i),ierr) 
!       make sure that message was send!
        call mpi_wait(ireq(i), status_mp, ierr)
        slaves(i) =  i 
      end do 
      
      worktag = sizee

      do while ((worktag .le. ntemp) .or. (sum(slaves) .gt. 0)) 

!    waiting to get an answer from any slave process 

       call mpi_recv(numslave ,1, mpi_integer, mpi_any_source, mpi_any_tag, comm, status_mp ,ierr) 
!    received an answer from any 

!    check if there is more work to be done

       if (worktag .le. ntemp) then 
         call mpi_Isend (Tpmask(worktag,2), 1, mpi_integer, numslave, sendtag(numslave), comm, ireq(numslave),ierr)
         call mpi_wait(ireq(numslave), status_mp, ierr)
         worktag = worktag+1
!    else send that the working loop has been finished
       else
         print*, 'all work done, completed on', numslave 
         slaves(numslave) = 0 
         call mpi_Isend (0, 1, mpi_integer, numslave, sendtag(numslave), comm, ireq(numslave),ierr)
         call mpi_wait(ireq(numslave), status_mp, ierr)


       end if 
      end do         
             
 

   else

! on all other cores (slaves) the actual calculations are done!

       call mpi_irecv(itemp, 1, mpi_integer, 0, sendtag(myrank), comm, ireq(myrank), ierr)

       call mpi_wait(ireq(myrank), status_mp, ierr)

#endif  


!-------------s t a r t  iterations over Temp:  loop 950 ---------------------!
    do while (moretemp)    

!----
#ifdef MPI
 
!-----------
         call ReadContinum ( myrank , comm, itemp, ncid, &
     &      wledge, freqedge, cmedge, idmol, momass, freqset, &
     &      tsave, p, t, rho, xne, xnatom, vturb, xnfh2, xnfhe, &
     &      xnfh, continall, contscat, xnfpel4, dopmax, dopple4,&
     &      nrhox, ntemp, nufreq , ier)

#else

      itemp = iteff
     call ReadContinum ( myrank , comm, itemp, ncid, &
     &      wledge, freqedge, cmedge, idmol, momass, freqset, &
     &      tsave, p, t, rho, xne, xnatom, vturb, xnfh2, xnfhe, &
     &      xnfh, continall, contscat, xnfpel4, dopmax, dopple4,&
     &      nrhox, ntemp, nufreq , ier)


#endif
      do j=1, nrhox
       t(j) = tsave(itemp)
      end do 

#ifdef MPI
      open(unit=12,status='new', file=trim(newdir)//'/fort.12', form='unformatted')
      open(unit=14,status='new', file=trim(newdir)//'/fort.14', form='unformatted')
#endif




       nedge = nufreq/3
       nufreq3 = nedge
!  ---- set coarse freq-grid on which the xndopmax and minimum continuum
! --- was calculated in the previous steps (mpsa.odfcalc.f90)

       wledge(1)=abs(wledge(1))

       do iedge=2,nedge
         wledge(iedge)=abs(wledge(iedge))
!        middle of the freq-bin -----
         halfedge(iedge-1)=(wledge(iedge-1)+wledge(iedge))*.5
!        (delta lambda)^(2)/ 2
         deledge(iedge-1)=(wledge(iedge)-wledge(iedge-1))**2*.5
       end do

      if (iteff .eq. 1) then 

       do i = 1, ntemp
        tkev(i) = k_ev * tsave(i)
        tk(i) = k* tsave(i) 
        hkt(i) = h/ tk(i) 
        tlog(i) = log(tsave(i)) 
        hckt(i) = hc/tk(i) 
       end do  
     
      endif
!---------------------------------------------------------------------!

      tlog10= log10(t(1))

      write(6,202)itemp,tlog10
202   format(//i3,' logt',f5.2)


#ifdef MPI 
!      time1= MPI_WTIME()
      call selectlines(n12,n19,itemp, newdir)
!      time2 = MPI_WTIME()
!      Atime(tcount,1) = time2-time1

#else
      call selectlines(n12,n19,itemp,currentdir) 
#endif
      irec=0

!----  do loop over atmospher (500-loop) -----------------------!         
      do j=1,nrhox
 
!----- just some print information which T, P we are calculating now

          tlog10=log10(t(j))
          plog10=log10(p(j))
          write(6,209)tlog10,plog10,ivt(1)
209       format(//' logt',f5.2,'   logp',f5.2,'   vt',f5.2)
   
          rewind 12
!----     initialize buffer
          length=3507859

          do  nbuff=1,lenbuff
            buffer(nbuff)=0.0d0 
          end do



          do  iedge=1,nedge-1

                ablog8(1,iedge)= continall(1+3*(iedge-1),j)! ablog(1,iedge)
                ablog8(2,iedge)= continall(2+3*(iedge-1),j)
                ablog8(3,iedge)= continall(3+3*(iedge-1),j) 

               if(deledge(iedge) .ne. 0.) then 

                  aedge(iedge)=(ablog8(1,iedge)-2.*ablog8(2,iedge)+ & 
     &             ablog8(3,iedge))/deledge(iedge)

                  bedge(iedge)=(-(halfedge(iedge)+wledge(iedge+1))* & 
     &                 ablog8(1,iedge)+(wledge(iedge)+wledge(iedge+1))* & 
     &                 2.0d0*ablog8(2,iedge)-(wledge(iedge)+ & 
     &                 halfedge(iedge))*ablog8(3,iedge))/deledge(iedge)

                  
                  cedge(iedge)=(halfedge(iedge)*wledge(iedge+1)* & 
     &             ablog8(1,iedge)-wledge(iedge)*wledge(iedge+1)* & 
     &             2.0d0*ablog8(2,iedge)+wledge(iedge)*halfedge(iedge)* & 
     &             ablog8(3,iedge))/deledge(iedge)
               end if
          end do
          
          nu=0
          iedge=1


          do nbuff=1,length
            wave=wbegin*ratio**(nbuff-1)

!           find right grid-point on freq-grid from pre-calculated xndopmax
!----------
             do while (wave.ge.wledge(iedge+1)) 
               iedge=iedge+1
             end do
 
            continuum(nbuff)=cutoff*10.**((aedge(iedge)*wave+ & 
     &                       bedge(iedge))*wave+cedge(iedge))

          end do

           xnfph(j,1)= xnfpel4(1,1,j) !xnfpel(1) 
           xnfph(j,2)=xnfpel4(2,1,j) ! 
           xnfphe(j,1)=xnfpel4(1,2,j)
           xnfphe(j,2)=xnfpel4(2,2,j)
           xnfphe(j,3)=xnfpel4(3,2,j)

           m = 1
           m2 = 0

           do  nelion=1,594
            m2 = m2 + 1
            if (m2 .eq. 7) then
              m2 = 1
              m = m+1
            end if

            xnfpel(nelion)=xnfpel4(m2 ,m,j )/rho(j)
            dopple(nelion)=dopple4(m2,m,j) 
            xnfdop(nelion)=xnfpel(nelion)/dopple(nelion)
           end do
      
           txnxn(j)=(xnfh(j,1)+0.42d0*xnfhe(j,1)+ & 
     &             0.85d0*xnfh2(j))*(t(j)/10000.0d0)**0.3d0



!     add lines to buffer
           mlines=0

#ifdef MPI
!      time3 = mpi_wtime()
#endif

           if(n19.gt.0)call dfxlinop(j,n19)

!----------lines from file/tape n 12 ( normal lines )-------------------------------!
                        
           if(n12 .ne. 0) then 

             l=10000
             selline = .true.

            do while ( selline)               
              l=l+1
              if(l.eq.10001)then
               read(12)tape12
               l=1
              endif
            
              nelion=itape12(3,l)
 

!  1st if in while 
              if(nelion.eq.0) then
                 selline = .false.
!  1st ifelse in while
              else
              
               contmin=continuum(itape12(1,l))
               kappa0=(tape12(2,l))*xnfdop(nelion)
! 2nd if in while 
               if(kappa0 .ge. contmin) then
                               
                mlines=mlines+1
                adamp=((tape12(4,l))+(tape12(5,l))*xne(j)+(tape12(6,l))* & 
     &              txnxn(j))/dopple(nelion)
                nbuff=itape12(1,l)
 ! 3rd if in while
!---------- compute voigt function inline
                if(adamp .le. 0.2d0)then
                 buffer(nbuff)=buffer(nbuff)+kappa0*(1.0d0-1.128d0*adamp)
                 tabstep=vsteps/(dopple(nelion)*resolu)
                 tabi=1.5d0 
!--------     profile inside 10 doppler widths
                 n10dop=int(10*(dopple(nelion)*resolu)) 
                 nstep = 0
                 logical2 = .true.

                 do while ((nstep .lt. n10dop) .and. logical2)   
                   nstep = nstep + 1
                   tabi=tabi+tabstep
                   profile(nstep)=kappa0*(h0tab(int(tabi))+adamp*h1tab(int(tabi)))
                   if(profile(nstep).lt.contmin) logical2 = .false. 
                 end do
! 4th if                  
                 if (logical2) then 
!---------     far wings
                  x=profile(n10dop)*dble(n10dop)**2
                  maxstep=int(sqrt(x/contmin)+1.d0 )
                  maxstep=min(maxstep,maxprof)
!     congf has been divided by freq
!     if congf is small, the wings are truncated at 100 doppler widths
!      if((congf*freq1000(nbuff/1000+1).lt.0.0001)

                  if((tape12(2,l))*freq1000(nbuff/1000+1).lt.0.0001) then
                     maxstep= min(maxstep,n10dop*10)
                  endif
                  
!     if the line is molecular, the wings are truncated at 100 doppler widths

                  if(mod(nelion,6).eq.0)maxstep=min(maxstep,n10dop*10)
                  n1=n10dop+1

                  do  nstep=n1,maxstep
                   profile(nstep)=x/dble(nstep)**2
                  end do
                  nstep=maxstep
                  logical2 = .false. 
                 endif
!  4th if closed!



! 3rd else if!
             else if(adamp.gt.100.0d0 )then
                  profilecenter=kappa0/adamp*.79788d0/1.4142d0
                  buffer(nbuff)=buffer(nbuff)+profilecenter
                  aa=adamp*adamp
                  dvoigt=1.0d0/dopple(nelion)/resolu
!------------  profile inside 10 doppler widths
!-----------     n10dop=10.*dopple(nelion)*resolu

                  nstep = 0
                  logical2 = .true.
                  
                  do while (nstep .lt. maxprof .and. logical2)
                  nstep = nstep +1 
                  profile(nstep)=profilecenter*aa/(aa+(nstep*dvoigt)**2)
                  if(profile(nstep).lt.contmin) logical2 = .false.
                  end do
! 3rd else if       
                else if(adamp.gt.1.40d0)then
                  aa=adamp*adamp
                  profilec=kappa0*adamp*.79788d0 
                  buffer(nbuff)=buffer(nbuff)+kappa0/adamp*.79788d0/ & 
     &                      1.4142d0*(1.0d0+(.75d0/aa-.5d0)/aa)
                  dvoigt=1.0d0/dopple(nelion)/resolu

                  nstep = 0
                  logical2= .true.
                  do while (nstep .lt. maxprof .and. logical2)
                   nstep = nstep +1
                   vv=(nstep*dvoigt)**2.0d0
                   u=(aa+vv)*1.4142d0 
                   aau=aa/u
                   vvu=vv/u
                   profile(nstep)=profilec/u*((((aau-10.0d0*vvu)*aau+ & 
     &                      5.0d0*vvu*vvu)/u+vvu-aau/3.0d0)*3.0d0/u+1.0d0)
                   if(profile(nstep).lt.contmin) logical2 = .false.
                  end do
! 3rd else
                else
                  aa = adamp*adamp
                  ia=int(adamp*200.0d0+1.5d0)  
                  profilecenter=kappa0*atab(ia,1)
                  buffer(nbuff)=buffer(nbuff)+profilecenter
                  dvoigt=1.0d0/dopple(nelion)/resolu
                  n5dop=int(5*dopple(nelion)*resolu) 
                  nstep = 0
                  logical2 = .true.
                  do while (nstep .lt. n5dop .and. logical2 )
                   nstep = nstep +1
                   ivo=int(nstep*dvoigt*200.0d0+1.5d0) 
                   profile(nstep)=kappa0*atab(ia,ivo)
                   if(profile(nstep).lt.contmin) logical2 = .false.
                  end do
                  if (logical2) then                  
                   profilec=kappa0*adamp*.79788d0 
                   nstep = n5dop                  
                   do while (nstep .lt. maxprof .and. logical2 )                      
                      nstep = nstep +1
                      vv=(dble(nstep)*dvoigt)**2
                      u=(aa+vv)*1.4142d0 
                      aau=aa/u
                      vvu=vv/u
                      profile(nstep)=profilec/u*((((aau-10.0d0*vvu)*aau+ & 
     &                             5.0d0*vvu*vvu)/u+vvu-aau/3.0d0)*3.0d0/u+1.0d0)
                      if(profile(nstep).lt.contmin) logical2 = .false.
                   end do
                  end if
                endif
 ! 3rd if closed
!--- here was 323--------------------      
                if((nbuff+nstep).lt.1.or.(nbuff-nstep).gt.length) then
                    
                else                    
                   if(nbuff.lt.length .and. nbuff .gt. 1) then
!---------   red wing and blue wing
                      maxred=min(length-nbuff,nstep)
                      minred=max(1,1-nbuff)
                      do istep=minred,maxred
                       buffer(nbuff+istep)=buffer(nbuff+istep)+ & 
     &                                     profile(istep)
                      end do
                     maxblue=min(nbuff-1,nstep)
                     minblue=max(1,nbuff-length)
                     do istep=minblue,maxblue
                        buffer(nbuff-istep)=buffer(nbuff-istep)+ & 
     &                                    profile(istep)
                     end do

                   else if (nbuff .lt. length) then 
!---------  only   red wing
                     maxred=min(length-nbuff,nstep)
                     minred=max(1,1-nbuff)
                     do istep=minred,maxred
                      buffer(nbuff+istep)=buffer(nbuff+istep)+ & 
     &                                     profile(istep)
                     end do
                   else if(nbuff .gt. 1 ) then
!--------  only    blue wing
                     maxblue=min(nbuff-1,nstep)
                     minblue=max(1,nbuff-length)
                     do istep=minblue,maxblue
                        buffer(nbuff-istep)=buffer(nbuff-istep)+ & 
     &                                    profile(istep)
                     end do
                   else

                   end if
                end if
               end if
! 2nd if closed
              end if    
! 1st if closed
            end do   ! (big while loop) 
           end if    ! 400 
         
#ifdef MPI
!         time4 = mpi_wtime()
!         Atime(tcount,2) = time4- time3

#endif
!-----------------------------------------------------------
!-------------------------------------------------------------

         do  nbuff=1,length
             buffer(nbuff)=max(buffer(nbuff), 1.0e-3*continuum(nbuff))
!            buffer(nbuff)=max(buffer(nbuff),1.0d-25) 
         end do
      
         rewind 14

         do  ik=1,lenbuff,10000
          write(14)(buffer(i),i=ik,ik+9999)
         end do
      
!---- some odd error in write - mismatch
         write(6,404)tlog10,plog10,ivt(1),mlines
  404    format(' logt',f5.2,'   logp',f5.2,'   vt',f5.2, & 
     &   '  spectrum completed with',i8,' lines')

!#ifdef MPI
!        time5 = MPI_WTIME()
!#endif 
    

! for some experiments write out opacity 
!---------------------------------------------------------------------------------------!
!         do  nbuff = 1, lenbuff
!         write(100+myrank, *) wlbeg*(1.0d0+1.0d0/500000.0d0)**(nbuff-1), buffer(nbuff) 
!         enddo  
!         call mpi_abort(MPI_COMM_WORLD, ierr)
!---------------------------------------------------------------------------------------


!---- calculate the sorted ODFs


! ------ if highresolution is used

         if (highres) then 
          call dfcalchighres(itemp,j,1,t(j),p(j),0.0d0, iwlstart)   
!------ if filters are used
         else if (ifilter .eq. 1 ) then 
          call dfcalc_filter(itemp,j,1,t(j),p(j),0.0d0) 

!------- if standard odfs are calculated
         else
          call dfcalc(itemp,j,1,t(j),p(j),0.0d0)
         end if 
#ifdef MPI
!        time6 = MPI_WTIME()
!        Atime(tcount,3) = time6-time5
!        time7 = MPI_wtime()
#endif


! --- loop over turbulent velocity velues ivt ( 430 )-------------------------------!
          do iv=2,numvt
            
             rewind 14
             do  i=1,lenbuff
               buffer(i)=0.d0 
             end do
             nbuff=-10000
             lastrec=length-(lenbuff-10000)
!---------- do 420 -------------------------------!
             do  ik=1,lenbuff,10000
              read(14)b10000
              nbuff=nbuff+10000
              do  i=1,10000
                buffer(nbuff+i)=buffer(nbuff+i)+b10000(i)*vtcenter(iv)
              end do
!---------- start if n20 ---------------------------------------!         

              if(ik.eq.1)then
               do  i=1,10000
                 do  iprof=1,nvt(iv)
                  buffer(nbuff+i+iprof)=buffer(nbuff+i+iprof)+b10000(i)* & 
     &                vtprof(iprof,iv)
                  end do
                end do
      
                do  i=1,10000
                 do  iprof=1,nvt(iv)
                   nback=nbuff+i-iprof
                   if(nback.gt.0)buffer(nback)=buffer(nback)+b10000(i)* & 
     &                                 vtprof(iprof,iv)
                 end do
                end do
      
              else 
      
                lastrec=10000
                if(ik.gt.lenbuff-10000)lastrec=length-(lenbuff-10000)
                do  i=1,lastrec
                 do  iprof=1,nvt(iv)
                  buffer(nbuff+i+iprof)=buffer(nbuff+i+iprof)+b10000(i)* & 
     &                     vtprof(iprof,iv)
                  buffer(nbuff+i-iprof)=buffer(nbuff+i-iprof)+b10000(i)* & 
     &                     vtprof(iprof,iv)
                 end do
                end do
               end if

             end do ! end 420

!--------------------------------!
             vt=ivt(iv) 
             write(6,405)tlog10,plog10,ivt(iv) 
405           format(' logt',f5.2,'   logp',f5.2,'   vt',f5.2, & 
     &              '  spectrum broadened')


!---- after the spectrum has been broadened we need to calculate the sorted ODFs again:

! ------ if highresolution is used:
              if (highres) then 
                call dfcalchighres(itemp,j,iv,t(j),p(j),vt,iwlstart)
! ------- if filter ODFs are used
              else if (ifilter .eq. 1) then 
                call dfcalc_filter(itemp,j,iv,t(j),p(j),vt) 
! ------- if standard ODF tables are used
              else
                call dfcalc(itemp,j,iv,t(j),p(j),vt)
              end if 

          end do !---- 430 ---!     
#ifdef MPI
!        time8 = MPI_WTIME()
!        Atime(tcount,4) = time8-time7
!        tcount = tcount +1
#endif

         end do !----------finish loop over all pressure point for one T value --500 loop--!

!------------------------------------------------!
        close(unit=12,status='delete')
        close(unit=14,status='delete')
        close(unit=19,status='delete')

        iteff = iteff +1


#ifdef MPI
! let the master know that you finished:
       call mpi_send(myrank, 1, mpi_integer, 0, recvtag(myrank), comm, ierr)

!  get the new job:
       call mpi_irecv(itemp, 1, mpi_integer, 0, sendtag(myrank), comm, ireq(myrank), ierr)

       call mpi_wait(ireq(myrank), status_mp, ierr)

       if (itemp .eq. 0) moretemp = .false.

#else
       if (iteff .gt. ntemp) moretemp = .false.

#endif

      end do 
!-----   950   loop closes   ------------------------------!!!!


#ifdef MPI
    end if ! master -slave destribution!
#endif


      do iv =1, numvt
 
#ifdef MPI
       call MPI_Barrier(comm, ierr)
!----    for timing purposes : 

!       if (iv .eq. 1) then 
!         time10 = mpi_wtime()
!         call mpi_allreduce(Atime, Rtime, 5700, mpi_double_precision, mpi_sum, comm, ierr)

!         if (myrank .eq. 0 ) then
!           write(81,*) 'time0, time10, difference:' , time0, time10, (time10-time0)
!           write(81,*) 'total amount in 1: ', sum(Rtime(:,1))
!           write(81,*) 'total amount in 2: ', sum(Rtime(:,2))
!           write(81,*) 'total amount in 3: ', sum(Rtime(:,3))
!           write(81,*) 'total amount in 4: ', sum(Rtime(:,4))

!           do i = 1, 1425
!             write(81,*) Rtime(i,1), Rtime(i,2), Rtime(i,3), Rtime(i,4)
!           end do
!         end if
!       end if 

#endif 


! -----------   Write out the calculated opacity tables: --------- !


            if (iv .eq. neediv) then 
            call write_odf(iv, comm, myrank,ntemp, ODFfile) 
            else 
             velf= char(iv+48) 
             if (ifkbin) then 
               ODFname = 'p00lit'//trim(velf)//'.bdf' 
             else  
               ODFname = 'p00all'//trim(velf)//'.nc'
             endif 
            call write_odf(iv, comm, myrank,ntemp, ODFname) 
            endif 
     
      end do 

#ifdef MPI
      if (myrank .eq. 0 ) then
       if (allocated(slaves))  deallocate(slaves) 
       if (allocated(Tpmask))  deallocate(Tpmask) 
      end if
      deallocate(sendtag)
      deallocate(ireq)
      deallocate(recvtag)
      deallocate(flagmpi)
#endif

      call CloseNetCDF (myrank, ncid, ier)
      call close_arrays

end subroutine
! ----------------------- END of opacity table calculation routine --------------! 

subroutine worksort(k, n, k1, ind, ind1)
    implicit none
    integer n, i, j, j0, j1, jj0, mask, max_val, k(n), k1(n)
    integer ind(n), ind1(n)


    mask = 1
    max_val = k(1)
    do j = 2, n
        max_val = max(max_val, k(j))
    end do

    do i = 1, 59
        if (i .ne. 1) then
            max_val = max_val / 2
            mask = mask * 2
        end if

        if (max_val .eq.  0) then
            return
        endif

        j1 = 0
        j0 = 0
        do j = 1, n
! --- this condition first takes the bit-wise intersection of the mask and the number, and than compares if it less equal 0
            if ((k(j) .and. mask) .le. 0) then 
                j0 = j0 + 1
                k(j0) = k(j)
                ind(j0) = ind(j)
            else
               j1 = j1 + 1
               k1(j1) = k(j)
               ind1(j1) = ind(j)
            end if
        end do

        if(j1 .ne.  0) then
            do j = 1, j1
                jj0 = j + j0
                k(jj0) = k1(j)
                ind(jj0) = ind1(j)
            end do
        end if
    end do
end subroutine 

 
